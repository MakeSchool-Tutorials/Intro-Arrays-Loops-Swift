/*:
 ![Make School Banner](./swift_banner.png)
 # 配列のきほん

 ライフゲームシミュレーションを作るために、まずは"palette"と呼ばれるものを用意します。これは、ユーザーが色々な`Characters`（文字）をこのシミュレーションで使うことができるようにするためのものです。まずは”一次元”配列を使います。

 どうしたら配列を操作できるか、いくつかの方法を実はもう学んでいます。配列は、普通の変数と同じように扱うことができます。下の例は、空の配列を"let"を使って初期化する方法です。

 */

let palette: [Character] = []

/*:

 - 注意: "String(文字列)"は"Character(文字)"からできています。"Character(文字)"は、"String(文字列)"の一要素で、２文字以上を保存することはできません。また、配列はどんなデータ型も保存することができます。（ただし配列に入っている全てのデータは同じデータ型でないといけません。）

 
 ## 配列を宣言する

 この"palette"のデータ型は、`[Character]`です。つまり、"Character(文字)の配列"がデータ型です。Character(文字)以外にも、どんなデータの配列も作ることができます。("String"の配列、"Int"の配列、"Character"の配列の配列（これは少しややこしいですが、この後登場します。））

 この"palette"はまずは何も入っていない配列として定義されています。カンマで区切って文字を[]の中に入力することで、文字の配列を作ることができます。

 - callout(試してみよう): 定義をした空の配列を下の配列に書き換えてみましょう。３つの要素が一つの配列に格納されます。どうpaletteが変化するか見てみましょう！

    `["🐱", "😀", "😜"]`


 - 重要: `control + command + space`を押すと絵文字キーボードが開きます。

 ## インデックス

 今`palette`には3つの要素が入っています。どうしたらこの要素を取り出すことができるでしょうか？　この_subscript(添字)_を使いましょう:
 
    palette[0]

配列から要素を取り出すためには、上の例のように配列の名前の後に取り出したい要素の番号を付け加えます。

 - 重要: 配列の番号は、0から始まります！つまり、`palette[1]`は、_2_つ目の要素を取り出すということになります。

下のイメージは要素が入った配列と、要素一つ一つに対応する番号を示しています。
 
 ![](array.jpg)

 */

let exampleArray = [2, 5, 1, 3, 4]
exampleArray[0]
exampleArray[1]
exampleArray[2]
exampleArray[3]
exampleArray[4]

/*:

 ## 添字を使って定義する

 - callout(試してみよう): _添字_を使うと、配列から要素を取り出すだけではなく、要素を定義することができます。これまでに学んだ定義の方法ととても似ています。下のコードを実際にコーディングエリアに書いてみましょう。

    `palette[0] = "😜"`


 */



/*:

 ### エラーが出てしまう！

 この上のコードはこのままでは動かないようです。

 - 重要: paletteは、`let`を使って定義しました。つまり、この値は変更ができない配列ということです。もし、paletteの値を後から変更可能にしたければ、`let`ではなく`var`を使って定義します。

これで要素0を😜に設定できます。初めと三番目の要素がこれで😜になっているはずです。

 */



/*:

 ## Append (アペンド)

 もし配列に要素を付け加えたかったら、どうしたらいいでしょうか？`palette[3] = "🐱"`では上手くいきません。なぜなら、定義した配列のサイズより大きな番号にアクセスをしようとするとエラーが出てしまうからです。ここで`append()`が登場します！


 - callout(試してみよう): このコードを試してみましょう。

    `palette.append("🐱")`

 新しい"🐱"が配列の後ろに追加され、配列の大きさが一つ増えました。

 - メモ: `count`を使うと、配列の大きさを知ることができます。

    `palette.count`

 上のコードは、いくつの要素が配列に入っているかを教えてくれます。

 下のスペースで試してみましょう。

 */




/*:

 - 注意: この配列の大きさを知るシンタックスは関数ではありません。よく見ると()がついていませんね！`count`は_プロパティ_ もしくは配列に紐づいている値です。ドットを使うことでこの値を取得することができます。

 ## For ループ

 これまで、一つずつ、要素を操作してきました。もし配列の複数の要素に、同じ操作をしたかったらどうすればいいでしょうか？ `for ループ` を思い出しましょう。`drawPolygon`で使いましたね。


    for index in 0..<5 {
        palette.append("😈")
    }

 */



/*:

 このコードを実行すると、5つの 😈 が配列の後ろに追加されているはずです。つまり、 {} の中のコードは５回実行されているということですね！これが_for ループ_の便利なところです。

 上のforループは、このように言葉で表現できます。

 - `index`を 0 にセットする
 - `index`が 5 より小さい時、{} の中のコードを実行する。実行する度に、`index`の値が 1 つずつ増える

 `index`の値は初め`0`、次のターンで`1`...のように繰り返されます。

 - 前回の `for　ループ`の使い方との違いに気づきましたか？今回、`index`というカウンター値を使いました。また、`0` の後 `...` ではなく `..<` を使っています。`..<`はその後の値より小さいという意味です。`0..<5`の時は 0 から 4 まで、`0...5`の時は 0 から 5 までという意味です。
 */
/*:
 - callout(試してみよう): `palette.count`はpaletteがいくつの要素を持っているかを教えてくれるものでした。5 の代わりにこれを使いましょう。そして添字を使って、indexと同じ位置番号の要素が 👾 に書き換わるようにしましょう。

 */





/*:

 これで全ての値を一度に書き換える方法がわかりましたね！

 ## for ループ 続き

 下のコードは先ほど学んだやり方です。

    for index in 0...5 {
        // do something
    }

 このループは `..<` ではなく `...` を使っています。つまりこのループは0から5までを表しています。つまり、6回コードが実行されるということです！

 - 重要: `...`を使う時は少し注意しましょう。配列の位置の番号は0から(配列の`count` - 1)の間です。下のコードはエラーが出てしまいます。なぜでしょう？

        for index in 0...palette.count {
            palette[index] = "😈"
        }

 ## for-in ループ

 これまで、forループを整数の値(index)を使って操作してきました。別の方法もあります。下のコードを使うと、整数の値を使わずに直接配列のデータを取り出すことができます。

    for element in palette {
 
    }

 これは下のコードと同じ操作をします:

    for index in 0..<palette.count {
        let element = palette[index]
    }

 - メモ:この新しいやり方はこのチュートリアルでは使いませんが、知っておくと後々便利です。

"Next"をクリックして次へ進みましょう！

*/
//: [Previous](@previous) | [Next](@next)




















/*:
Don't worry about this code. It handles the display.
*/
import PlaygroundSupport
import SpriteKit
let size = CGSize(width: 320, height: 568)
let sceneView = SKView(frame: CGRect(origin: CGPoint.zero, size: size))
sceneView.wantsLayer = true
let scene = SimulationScene(fileNamed: "SimulationScene")!
scene.setup(simulation: EmptySimulation(), palette: convertToOptional(palette))
scene.scaleMode = .aspectFill
sceneView.presentScene(scene)
PlaygroundPage.current.liveView = sceneView
