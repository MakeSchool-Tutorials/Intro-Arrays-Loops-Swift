/*:
 ![Make School Banner](./swift_banner.png)
 # 配列入門

配列はデータの集まりを操作するために必要なものです。これまで、一つ一つの値を変数や定数に保存することは学びましたね。（'let'や'var'を使いました。）では、もしたくさんのデータを保存したかったら、どうすれば良いでしょうか。一つ一つに変数や定数を定義していたら大変ですね。

 配列というのは、一つ一つの要素をリストにいれて保存していくことで、この問題を解決してくれるのです。バケツが一列に並んでいて、その一つ一つにデータを保存できるようなイメージです。

 ![](array.jpg)

 このチュートリアルでは、配列を作る方法、その中のデータを"for-loops"というものを使って操作する方法を学びます。その知識を使って、「ライフゲーム」と呼ばれる有名なシミュレーションをコードで実装していきます！

 # ライフゲーム（Conway's Game of Life）

 ![](not-game-of-life.png)

いや、これではないですよ！

 ![](gol.png)

 ライフゲーム（Conway's Game of Life）は実はいわゆるゲームとは少し違います。これは[_セル・オートマトン_](https://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%AB%E3%83%BB%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3)と呼ばれる、２次元のグリッドにセルの誕生や進化、淘汰を表現するシミュレーションなのです。セルが塗りつぶされたり、白に戻ったりします。まるで微生物やバクテリアが広がるように、条件によって黒のセルが増えたり、減ったりします。

まず初めのステップで、生きたセルと死んだセルの配置を決めるところからスタートします。そして各ステップで、下のルールに従って各セルは更新されます。
 
 - 周りに生きているセルがいくつあるかを数える
 - 自分が生きているセルだったら:
    - もし周りの生きているセルが1つ以下であれば、過疎により死滅する。
    - もし周りに２つもしくは３つの生きたセルがあれば、生き続ける
    - もし周りに４つ以上の生きたセルがあれば、過密により死滅する。
 - 自分が死んだセルだったら:
    - もし周りにちょうど３つの生きたセルがあれば、次の世代が誕生する！（生き返る）

上のものは基本的なルールに見えますが、実は生命の誕生・淘汰などの出現をとても上手に表します。例えば、下のような現象がライフゲームで見つかるでしょう！
 
 - callout(パルサー): ![](Game_of_life_pulsar.gif)
 */
/*:
 - callout(グライダー): ![](Game_of_life_animated_glider.gif)
 */
/*:
 - callout(グライダー銃): ![](Gospers_glider_gun.gif)

 "Next"ボタンを押して早速ライフゲームを作ってみましょう！

*/
//: [Next](@next)
